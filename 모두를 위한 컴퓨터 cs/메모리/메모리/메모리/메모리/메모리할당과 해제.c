#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main_f(void)
{
    char* s = get_string("s: ");
    char* t = malloc(strlen(s) + 1); 

    strcpy(t, s);

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);

    free(t);
}

/*
위코드에서
malloc라는 메모리 할당 함수.

get_stringd은 입력받은 문자열의 주소를 돌려준다.
malloc도 비슷한 값을 돌려준다.
할당한 메모리의 첫 바이트 주소를 돌려준다.

메모리 할당이란 메모리 일부분을 가져와서 그곳을 가리키는 포인터를 주는것이다. 
저 주소는 우리가 기억해야 하므로 여기에서처럼 t에 저장한다.

이 코드 버그 잇슴.
메모리 할당받았지만 해제하지않음. 
그렇지 않은 경우 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하게 되기 때문이죠.
이러한 현상을 ‘메모리 누수’라고 일컫습니다.

malloc의 반대는 free라는 함수 
free함수는 
할당 되었던 메모리를 다시 반환한다.
쓰는 이유 그래야 더많은 메모리를 사용할 수 있게 된다.
malloc으로 메모리를 많이 할당하지만 전혀 해제하지않으면 메모리가 바닥이 나서 메모리 부족현상발생

이런 실수를 찾기 위한 디버깅 툴
valgrind라는 프로그램.

help50 valgrind ./filename
이걸로 문제가 메모리 누수가 되는 부분을 찾고.
코드아래쪽에 fere(t)적으면됨.
*/

#include <stdlib.h>

void f(void)
{
    int* x = malloc(10 * sizeof(int));
    x[10] = 0; //이코드 오류. 이유: 10번쨰느 없다. 10개의 정수가 있다면 0~9까지고 10은 없다. 버퍼 오버플로우의 예시.
}

int main_g(void)
{
    f();
    return 0;
}

/*
  int* x = malloc(10 * sizeof(int));
 설명: 메모리의 주소를 x라는 포인터에 저장합니다. sizeof쓰고 괄호사이에 자료형 쓰면 크기를 알려줌. 인트형은 4바이트
 그래서 10*4는 40바이트 메모리 요청한거. 사실상 정수를 저장하는 메모리의 배열.

  x[10] = 0; 
  오류 이유: 10번쨰는 없다. 10개의 정수가 있다면 0~9까지고 10은 없다. 버퍼 오버플로우의 예시.

  버퍼 오버플로우
  메모리 or 메모리 배열을 다룰 떄 여기서는 연속된 공간에 정수가 10개 있는데 
  그 공간을 넘어 접근한다면 이런 상황을 버퍼 오버플로우라고함.
  버퍼는 배열

  저 위의 코드에서 메모리 해제하기위해 free(x); 추가하면됨.
*/