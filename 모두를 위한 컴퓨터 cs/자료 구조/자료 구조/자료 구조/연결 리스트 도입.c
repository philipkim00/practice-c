/*
배울 내용은 
struct(구조체)

점 표기법
사용처: 빨간 초록 파랑 픽셀을 조작할떄 사용, 구조체의 속성값(이름,번호)에 접근할때 사용

*(별표 연산자)
별표 연산자는 메모리 덩어리로 접근할 수 있는 역참조 연산자다.(포인터를 이용해서)!

연결 리스트(linked lists)
값들의 리스트를 저장하는 방법.
배열도 이러한 값들의 리스트를 저장할수 있다.
그렇지만 단점이 있다.
1. 고정된 메모리 덩어리
2. 배열의 크기를 조절할떄는 더많은 값을 넣고 싶다면 최소한 더많은 메모리를 할당해야한다.
(기존 배열에서 새 배열로 이 모든 값들을 복사해야 하기 떄문에.)

배열의 장점
1. 대괄호를 이용해서 쉽게 인덱싱을 할수 있다.
2. 배열은 빠르다(컴퓨터의 0,1,2,3,의 위치로 바로 접근해서)
3. 바이너리 검색 같은 곳에 적용 할수 있다.


모든 요소들을 서로서로 옆에 붙이는게 아니라 계속 추가할 수 있을만큼 메모리가 남아 있기를 바라기보다는 
조금더 효율적인 방법이 있음

배열에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있습니다.

하지만 꼭 그럴 필요가 있을까요? 각 값이 메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 여전히 값을 연이어서 읽어들일 수 있습니다.

이를 ‘연결 리스트’라고 합니다. 아래 그림과 같이 크기가 3인 연결 리스트는 각 인덱스의 메모리 주소에서 자신의 값과 함께 바로 다음 값의 주소(포인터)를 저장합니다.

사진 

연결 리스트의 가장 첫 번째 값인 1은 2의 메모리 주소를, 2는 3의 메모리 주소를 함께 저장하고 있습니다.

3은 다음 값이 없기 때문에 NULL (\0, 즉 0으로 채워진 값을 의미합니다)을 다음 값의 주소로 저장합니다.

연결 리스트는 아래 코드와 같이 간단한 구조체로 정의할 수 있습니다.

typedef struct node
{
    int number;
    struct node *next;
}
node;

node 라는 이름의 구조체는 number 와 *next  두 개의 필드가 함께 정의되어 있습니다.
number는 각 node가 가지는 값, *next 는 다음 node를 가리키는 포인터가 됩니다.
여기서 typedef struct 대신에 typedef struct node 라고 ‘node’를 함께 명시해 주는 것은, 
구조체 안에서 node를 사용하기 위함입니다.

여기서 사각형(사진에 네모들)을 node라고 부름
컴퓨터 공학에서 node라는 단어는 직사각형으로 나타낼 수 있는 메모리 덩어리를 의미한다.
여러 목적에 사용.

*/

