/*
해시 테이블

일정한 시간을 가지는 자료 구조를 발견하면 좋지않을까?
만약에 어떤 것을 자료 구조에 넣을 떄 
단 한 단계만에 할 수 있고
자료구조에서 무언가를 한 번만에 찾을 수 있다면
말하자면 정말 성스러운 것이죠
왜나하면>?
O(n)인지 O(log n)인지 신경쓰지 않아도 되니까

이론적으로 이걸 가능하게해주는것이 
해시 테이블이다.

해시 테이블은 ‘연결 리스트의 배열’입니다. 여러 값들을 몇 개의 바구니에 나눠 담는 상황을 생각해 봅시다.

각 값들은 ‘해시 함수’라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정 됩니다.

근데 각 바구니에서 새롭게 정의되는 연결리스트가 없다면 한 바구니에서 충돌을 하게됨
어떤 값을 넣을려고 하는데 이미 무언가 들어 있는 경우 어떤 방법으로든 이를 해결해야함.

해시함수 지금까지본 다른함수와 똑같다. 입력값을 받아서 출력값을 내보내는 것.


해결법.
각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의되는 연결 리스트로 이어집니다.

이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것이 ‘연결 리스트의 배열’, 즉 ‘해시 테이블’이 됩니다.



쉬운 예로 아래 그림과 같이 사람의 이름이 해시 테이블에 저장되며, 해시 함수는 ‘이름의 가장 첫 글자’인 경우를 생각해 보겠습니다.

그 경우 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있으며, 각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 됩니다.

Albus -> ㅁㅁㅁㅁ해시함수 -> 0 
0이 반환되어 0번쨰 배열에 들어감 
Zacharias -> 해시함수-> 25

사진

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 될 것입니다.

따라서 검색 시간은 O(1)이 됩니다.

하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 O(n)이 될 수도 있습니다.

모든 사람의 이름이 H나 L로 시작하거나 존나 많으면? 
얼마나 멋지게 해시 테이블을 만들든 모든 이름표가 바구니에 쌓아있을걸.
이 문제 완화방법.
이름 첫글자만 보지말고 첫 두번쨰 글자도 보기 (Hermione, Harry ,Hagrid)

첫글자 H만 보면 겹침(충돌)  HA,HB HC HD HE HG바구니가 있슴.
26X26 =676가지 
공간은 많아지겠지만 충돌할 확률은 낮아짐
그렇지만 또 Hagrid 가 문제가있슴 그래서 
첫 세번쨰 글자까지 보고
26x26x26= 17576 
칸의 갯수가 존나 많아짐 충돌 확률이 줄어듬 Haa,Han Hac Had Hae ... Haq  Har ...

저 세개의 이름을 이제 해시하면 모두 다른 바구니에 들어가게됨.
개선됨 실제로도 이제 탐색을 할 때 이름을 찾을 수있음(충돌x) 한번에 찾을수 있다.
하지만
어디까지나 H로 시작하는 이름이 그렇게 많지 않다고 가정했을 떄다.
그렇기 때문에 해시 테이블의 실행 시간은 여전히 O(n)이다.
왜냐하면 
운 나쁘게 비슷한 이름이 한 무더기 들어오게 되면 그렇게 되서 모두 같은 값을 가지게 되면
지금 만든 멋진 해시 테이블을 사용한다고 해도 또 다시 부작용 생김.
2만 개에 가까운 바구니를 사용해서
속도를 빠르게 하려고 햇지만
어느 순간부터는 저 세이름을 그냥 연결하는 것이 더 좋음
그리고 그냥 이름표를 찾는데 시간이 좀 더 걸리는 것이 낫음.

하지만 
어떤 이상적인 해시 함수를 가지고 있다면 이름표들이 각각 다른 결과를 가져서 충돌이 서로 일어나지 않도록하는
엄청난 알고리즘을 코드로 구현할수 잇다면
정말 대단한 O(1), 즉 일정한 실행 시간을 가질 수 잇다.

일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 거의 O(1)에 가깝다고 볼 수 있습니다.

*/