/*
배열에 비해서 연결리스트가 더 퇴보적이지않냐?

배열에서는 모든 것을 기존 배열에서 새로운 배열로 복사해야 해서 
조금 오래 걸리긴 하지만 크기를 바꿀 수도 있고
임의 접근을 통해서 이진 탐색도 쓸수 있고
정렬된 리스트에서 탐색할 떄 실행 시간이 
log n이기 때문에 
연결 리스트를 쓰면 이걸 포기한것 아니냐?

연결 리스트는 역동성을 준다
값들을 옮기느라 시간을 낭비하지 않고 일을 할 수 있다. 
하지만 임의 접근 못함
하지만 포인터와 자료 구조를 사용해서 메모리에 여러 요소를 잇고 
화살표를 이용해서 붙여서 더 멋진것을 만들수 있다.


계층적인 2차원 구조이다.
실제로 가계도가 우리의 영감이다.

1차원적인 자료 구조만 게속 만드는것이아니면 
배열은 왼쪽->오른쪽으로만 움직이고 연결리스트도 똑같음.
수직적인 개념을 사용해서 더흥미로운 방식으로 요소들을 배열한다면? 어떨까?

배열을 볼때마다 배열을 새롭게 구현해왓슴,
하자만 배열과 연결 리스트의 장점만 가져오면 어떨까/



포인터라는 개념을 이용해서 더많은 포인터를 사용하면? 
더 많은 공간을 할당하고 이 자료 구조들을 이어 붙여서 
개념상 2차원으로 만드는것.!
저사진에서 나온 직사각형 node들은 꼭 하나의 포인터만 가져야 할 필요 x
새로운 구조체를 만들면 그만. 
두개의 포인터를 가진 node를 만들고 왼쪽 포인터(left) 오른쪽은(right)라고 부름
이전 연결리스트에서는 next라는 포인터 하나만 있엇다.

트리는 연결리스트를 기반으로 한 새로운 데이터 구조입니다.

연결리스트에서의 각 노드 (연결 리스트 내의 한 요소를 지칭)들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성되어 있다고 볼 수 있습니다.

각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가지게 됩니다.

아래 그림은 트리의 한 예입니다. 나무가 거꾸로 뒤집혀 있는 형태를 생각하면 됩니다.

가장 높은 층에서 트리가 시작되는 노드를 ‘루트’라고 합니다. 루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 ‘자식 노드’라고 합니다.

사진

트리의 노드들이 모두 최대 두 개의 자식 노드가 있고
그래서 이진법의 이진을 따와서 최대 2라는 것을 표현함.
저 파란색 아래쪽에는 0개의 자식 노드를 가지고 있고
노란색에서는 최대 2개의 자식 노드를 가짐.
그렇기 떄문에 '이진'이라는것.

순서를 맞추기 위해 신경을 썻다는 의미에서 '탐색' 트리임. 

그래서 위 그림에 묘사된 트리는 구체적으로 ‘이진 검색 트리’ 입니다.


각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있습니다.

먼저 하나의 노드는 두 개의 자식 노드를 가집니다.

또 왼쪽 자식 노드는 자신의 값 보다 작고, 오른쪽 자식 노드는 자신의 값보다 큽니다.

따라서 이런 트리 구조는 이진 검색을 수행하는데 유리합니다.

사실 재귀에 가장 적합한 방법.

아래 코드에서는 이진 검색 트리의 노드 구조체와 “50”을 재귀적으로 검색하는 이진 검색 함수를 구현하였습니다.

*/

//이진 검색 트리의 노드 구조체
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;

   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}

/*
이진 검색 트리를 활용하였을 때 검색 실행 시간과 노드 삽입 시간은 모두 O(log n) 입니다


값을 검색할 때 이진 검색 트리가 기본 연결 리스트에 비해 가지는 장점과 단점은 무엇이 있을까요?
장점 : 빠르다 (검색 및 삽입 모두  O(log n))

단점 : 메모리 차지가 많이 된다.

*/

