/*
트라이(tries) 
검색(retrieval)의 줄임말

한 가지 방법을 더 시도해보자(트라이)

또 다른 자료 구조를 제시하고자 함

트라이는 대단한 자료 구조이다.
어떤 자원을 절약하기 위해 다른 자원을 소비하는 패턴을 가짐.

많은 메모리가 들지만 자료 구조 안에 있는 이름이나 단어를 찾는 데 일정한 실행 시간을 가짐

‘트라이’는 기본적으로 ‘트리’ 형태의 자료 구조입니다.

특이한 점은 각 노드가 ‘배열’로 이루어져있다는 것입니다.

예를 들어 영어 알파벳으로 이루어진 문자열 값을 저장한다고 한다면 이 노드는 a부터 z까지의 값을 가지는 배열이 됩니다.

그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킵니다.



아래 그림과 같이 Hermione, Harry, Hagrid 세 문자열을 트라이에 저장해보겠습니다.

저 트라이에 이름 하나 저장하고 싶은경우
그 이름의 모든 글자를 본다. Harry면
한글자씩다 분해해서 봄. H a r r y 
사람의 이름이나 현재 저장하고 싶은 단어의
첫글자가 H라고하면 우선 해당 인덱스로감
만약 거기에 자식 노드가 없으면
그 아래에 다른 트리, 혹은 가지가 없으면 새로운 노드를 할당한다.
그리고 새로운 노드는 다시 말해 새로운 배열에서 a를 인덱싱함
그리고 같은 방법으로 r r y하고 
y에서 C언어에서는 불리언 연산식으로 이름 하나가 끝난다는 것을 표기함.


루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주면 됩니다.

사진

궁극적으로 트라이가 멋진 이유는?
이 자료 구조에서 n명의 사람들이 잇으면
누군가를 찾기 위한 실행시간은?
현재 노드가 많이 존재함에도 불구하고 총 3명만 들어 있기 떄문에 n은 3이다.

위와 같은 트라이에서 값을 검색하는데 걸리는 시간은  ‘문자열의 길이’에 의해 한정됩니다.

단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되니까요.

일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않은 상수값(예, 20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있습니다.

지금 까지 배운 다른 검색 및 알고리즘들은 자료 구조에 있는 이름들의 개수에 따라 실행 시간이 길어졌지만
트라이는 그렇지않음
되게 빠른 실행시간을 위한 대가가 있슴
메모리가 존내 많이 필요함.
이 자료 구조(트라이)는 매우 넓고 밀도 가 높음
이론적으로 상수 시간의 실행 시간을 제공하기 위해
아주 많은 양의 메모리를 사용하기 떄문에!
*/