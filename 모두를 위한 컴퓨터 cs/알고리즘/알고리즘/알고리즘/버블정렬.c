
/*
input -> ㅁ -> output
숫자를 정렬해야함.!
대가가 있슴.(시간)
정렬하는데 시간이 필요.
그래야 알고리즘 수행가능.

정렬하는데 얼마나 많은 시간이 필요할지?

꼭 정렬한 후 숫자를 찾아야 할지 아니면 정렬을 하지 않고 바로 탐색하는 게 좋을지
특히 한 방법이 더 오래 걸린다면?

input -> ㅁ -> output
unsorted(정렬되지않는 숫자) -> ㅁ -> output
목표 정렬하여 반환하는것.!

버블 정렬
정렬되지 않은 리스트를 탐색하는 것 보다 정렬한 뒤 탐색하는 것이 더 효율적입니다.

정렬 알고리즘 중 하나는 버블 정렬입니다.

버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말합니다.

버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중합니다.

이 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있습니다.

7 2 1 6 3 4 50 -> ㅁ -> 1 2 3 4 5 6 7 50
이것이 목표.

아래와 같은 8개의 숫자가 임의의 순서로 나열되어 있습니다.

이 숫자들을 오름차순으로 정렬하기 위해 바로 옆의 있는 숫자들과 비교하는 방법을 사용해 보겠습니다.

6 3 8 5 2 7 4 1

먼저 가장 앞의 6과 3을 비교해서 순서를 바꿉니다.

교환 전: 6 3 8 5 2 7 4 1

교환 후: 3 6 8 5 2 7 4 1

다음 쌍인 6과 8을 비교해보면 교환할 필요가 없으므로 그대로 둡니다.

바로 다음에 있는 쌍인 8과 5를 비교해서 순서를 바꿉니다.

교환 전: 3 6 8 5 2 7 4 1

교환 후: 3 6 5 8 2 7 4 1

이런 식으로 숫자 끝까지 진행하면 아래와 같이 정렬이 됩니다.

3 6 5 2 7 4 1 8

하지만 아직 오름차순으로 정렬이 되지 않았기 때문에, 다시 처음부터 동일한 작업을 반복합니다.

3 6 5 2 7 4 1 8

3 6 5 2 7 4 1 8 (교환)

3 5 6 2 7 4 1 8 (교환)

3 5 2 6 7 4 1 8

3 5 2 6 7 4 1 8 (교환)

3 5 2 6 4 7 1 8 (교환)

3 5 2 6 4 1 7 8

조금 더 잘 정렬이 되었습니다. 이 과정을 끝까지 반복하면 최종적으로 아래와 같이 오름차순 정렬이 될 것입니다.

1 2 4 3 5 6 7 8

이러한 정렬 방식을 ‘버블 정렬(bubble sort)’이라고 합니다.

마치 거품이(비교 및 교환이) 터지면서 위로 올라오는 (배열의 옆으로 이동하는) 방식이기 때문입니다.
아래와 같이 의사 코드로 나타낼 수 있습니다.

Repeat n–1 times
    For i from 0 to n–2
        If i'th and i+1'th elements out of order
            Swap them

버블 정렬의 실행 시간의 Big-O 표기는?
(n-1)x(n-1) 
n^2 -n -n +1 
n^2 -2n +1
O(n^2) - 버블정렬
여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 버블 정렬 실행 시간의 상한은 O(n^2)이라고 말할 수 있습니다.

선형검색 보다 이진탐색이 더좋았다 (더빨라서)
하지만 가정 정렬이 되있다는 가정이있었기때문에.
그래서 이진 탐색이 선형탐색보다 좋다고 하는 건 맞지 않다.(정렬하는데 얼마나 소요되는지 몰라서)

상황에 따라 배열에 대해 여러 번 탐색을 해야 하는 경우라면 한번 정렬해두는게 좋을것.

버블 정렬의 Omega는?
정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로 위와 같은 코드로 작성한 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 됩니다.

*/