/*

선택 정렬
보통 배열이 정렬되어 있으면 정렬되지 않은 배열보다 더 쉽게 탐색할 수 있습니다.

정렬을 위한 알고리즘 중 선택정렬을 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬입니다.

선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가합니다.

다음과 같은 정렬되지 않은 숫자들을 오름차순 정렬해보도록 하겠습니다.

6 3 8 5 2 7 4 1

먼저 아래 숫자들 중에서 가장 작은 값을 찾습니다.(1)

6 3 8 5 2 7 4 1

가장 작은 값인 1은 가장 앞에 있어야 하므로 현재 리스트의 첫 번째 값인 6과 교환합니다.
(교환하는 이유는 하나하나 밀어서 공간을 만들어도되지만 배열의 크기가 고정되어 잇으니 교환하는게 맞다.) 

1 3 8 5 2 7 4 6

그리고 정렬되어 있는 1은 제외하고, 두 번째 숫자부터 시작해서 또 가장 작은 값을 찾습니다.
(1을 제외하고 왼쪽부터 가면 2를 하고나서 바로 바꾸고 싶겟지만 컴퓨터는 한번에 하나씩만 저장 할수 있기 떄문에 계속 살펴봄, 
여러개의 변수를 저장하면 이야기는 달라짐 ㅋ?)

1 3 8 5 2 7 4 6

가장 작은 값인 2는 정렬되지 않는 숫자들 중에서 가장 앞에 있어야 하므로 3과 교환합니다.

1 2 8 5 3 7 4 6

이 과정을 더 이상 교환이 일어나지 않을때까지 반복하면, 아래와 같이 오름차순 정렬이 완료됩니다.

1 2 3 4 5 6 7 8

이러한 정렬 방법을 ‘선택 정렬’ 이라고 합니다. 의사 코드로 아래와 같이 표현할 수 있습니다.
습관화 해야할것.
어떤 상황에서든 n개의 항목이 있다면
첫번쨰 항목은 0번쨰이고 마지막 항목은 n-1번쨰
컴퓨터 과학자는 0 ~ n-1을 1부터 n을 세기 위해 사용.

For i from 0 to n–1
    Find smallest item between i'th item and last item
    Swap smallest item with i'th item

Big-O?
배열 정렬하는데는 얼마나 걸릴까
n+(n-1)+(n-2)+...+1 = n(n+1)/2 =(n^2+n)/2 = (n^2)/2+ n/2 그래서 빅o표기법에서느 n^2중요함.
O(n^2)

Omega
맨앞에 1을 확인해도 다른 수에 대한 정보가 없기때문에 프로그램은 배열 속 다른 값을 전부 보기 전까지 알 수 없다.
즉 선택정렬을 사용해도 앞에 놓인 수만 알 수 있기 떄문에 같은 코드를 게속 반복한다.
그래서 하환가도 오메가(n^2)
Ω(n^2)

선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까요?
먼저 '효율성'이란 말을 어떻게 적용할 것인지를 생각하고 넘어갈 부분 같네요.
만약 선택정렬의 의미를 살린다면 수행 시간의 big-O notation은 O(n^2) 이하가 될 수 없습니다.
그렇다면 big-Omega notation을 생각하면 어떨까요? 강의 마지막 부분에 교수님께서도
'이미 정렬이 되어있는 배열을 써도 시간은 변함없다'
라고 하시면서 아쉬움(?)을 표하신 것으로 미루어 보았을 때, 선택정렬의 효율성을 높이는 뜻은 수행시간의 하한선, 즉 가장 빨리 정렬이 가능할 때의 효율성을 높이는 것으로 접근할 수 있습니다.
 선택정렬에서 저희가 n-1번 동안 최솟값을 선형 탐색으로 찾습니다. 그런데 저희는 최솟값을 찾는 선형탐색을 이용한다면 맨 앞에서부터 어디까지 정렬이 되어있나 또한 최솟값을 찾는 동시에 찾을 수 있을 것입니다. 따라서 이 부분만 선택정렬에 추가해도 완전히 정렬된 배열에서는 Ω(n)이 될 수 있죠. 조금 더 나아가서 찾은 최솟값을 이분탐색을 이용해 앞의 정렬된 부분에 적당한 위치에 넣어 주는 로직또한 추가한다면 전반적인 수행시간이 감소할 수 있을 것입니다. 하지만 아무리 최적화를 한다고 해도 선택정렬의 의미를 살리는 한 O(n^2)은 벗어날 수 없습니다.
+) 아래의 댓글에서 최댓값과 최솟값을 같이 정렬하면 것에 대해 많은 이야기가 나왔는데, 루프가 n/2로 줄어드는 것은 맞지만 하나의 루프 안에서 if 조건문 연산을 2번씩해야 하므로 결과적으로는 시간의 차이는 없습니다.
*/