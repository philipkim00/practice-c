#include <stdio.h>

int main(void)
{
	// 자료형 : 변수가 어떠한 형태를 나타내는지를 설명해주는 역할이 자료형에 역할.
	// : (크기단위, byte) Date Type
	// 정수형 : char(1) , short(2), int(4) , long(4) , long long(8) ,더있슴
	// 실수형 : float(4), double(8)

	int i = 0;
	// 1.i안에 들어가는 데이터는 정수 표현방식을 따른다. 
	// 2. i라는 변수의 크기는 4바이트이다.

	// 1 바이트로 양수만 표현
	// 256가지 -> 0~255
	unsigned char c = 0; // 1바이트 양의 정수만 내포하는 자료형.
	c = 0;
	c = 255;
	c = 256; //짤려서 못들어옴. 


	//바이트 양수, 음수 둘다 표현
	// -128 ~ 0 ~ 127 
	/*signed*/ char c1 = 0;
	//signed 키워드가 기본적으로 생략되있고 음수 양수 둘다표현하지만 기본적인 전제라 적지는않음.
	c = -1;

	// 음의 정수 찾기(2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다.

	int a = 4 + 4.0;

	// 정수표현 방식과 실수 표현 방식은 다르다
	// 실수 표현방식은 정밀도에 의존한다.
	// 따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

	// 정수는 정수끼리, 실수는 실수 끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.

	float f = 10.2415f + (float)20;

	return 0;
}


/*
# 실수(소수)
정수데이터와 실수데이터를 구분 하는 이유는 정수타입데이터와 실수타입데이터를
처리하는 방식 자체가 완전히 다르다

우리가 표현할  수 있는 수는 Byte크기에 따라 한계가 있다.
그러나 실수는 무한대로 수를 늘릴 수 있다.컴퓨터는 무한히 많은 실수들의 각각의 비트가 설정되어 있지않다.
컴퓨터에서 실수를 표현하는 방식은 "부동소수점"이라는 표현체계를 따르고 있다.

정수와 실수데이터가 혼합되어 연산할 때 둘 중 한쪽 방식을 컴퓨터에게 선택시켜줘야한다.
똑같은 값이라 하더라도 정수와 실수에 따라 표현되는 비트가 완전히 다르다.
예) int a = 4 + 4.0; < -4와 4.0을 연산시킬 때 결과값을 정수로 할 것인지 실수로 할 것인지를 결정해줘야 한다.
	int자료형을 썻으므로 정수로 결과를 저장한다고 선택해줬다.
	계산과정 속에서 4 + 4.0이라는 계산을 연산하기 위해 실수체계표현에서 정수체계표현으로 "형변환"을 한 뒤에 계산했다.

	컴퓨터는 실수에서의 계산을 특정 숫자를 정확하게 표현하는게 아닌, "근삿값"으로 표현한다.
	그렇기 때문에 올바른 계산식을 썻는데도 소수를 정확하게 계산하지 못해 버그가 생길 수 있다.

	정리) 정수표현 방식과 실수표현 방식은 다르다.
	실수표현 방식은 정밀도에 의존한다.
	따라서 double(8Byte) 자료형이 float(4Byte) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.
	정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.

	![](https://velog.velcdn.com/images/philipkim00/post/c055a494-86e9-450c-8b16-8f36d9d6d66b/image.png)

10진수 10묶음이 모이면 다음자리로 넘어간다.
ex)51.1
여기서 소수점 0.1은 1을 기준으로하면 0.1이 10묶음 모여야 된다.
그렇다면
2진법에서 0.1은 2분에 1이다.  0.01은 4분에1이다.
아래로 소수점이 내려갈수록 2진법은 2분에 1씩 하면됨.
예시)
10진법 0.8125 을 2진법으로 바꾸기.
0. 1 1 0 1 0
이유 맨앞 1 = 0.5  두번쨰 1 0.25 네번째 0.0625
다 더하면 0.8125 이기떄문에.
11010이당.

![](https://velog.velcdn.com/images/philipkim00/post/769d447a-36c5-4c66-9481-2e5e1c4fb104/image.png)

(0 / 00000101/     /101011101000 / 0000000000000)2
+ (부호비트) / 5(e비트지수) / 비트번호

실수에 표현방식에서는 특정실수에 딱 떨어지는 비트가 존재 보다는 근사한 값으로 비트를 잡아준다.(정확히 떨어지는게 빡세서.)

## 정수표현방식과 실수표현에 메모리상에서 두 방식의 표현체계가 전혀 다른 방법으로 동작한다는것(확실하게 기억해라)

정수표현 방식과 실수 표현 방식은 다르다
실수 표현방식은 정밀도에 의존한다.
따라서 double(8) 자료형이 float(4) 보다 더 아래의 소수점까지 정확하게 표현이 가능하다.

정수는 정수끼리, 실수는 실수 끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하자.

float f = 10.2415f + (float)20;
설명:
정수 20을(float)형변환하기 그렇지만 이미(float)생략해도 앞에 float가 알아서 형변환 해주지만 명시적으로 컨트롤하자(float같은거표시).!

*/